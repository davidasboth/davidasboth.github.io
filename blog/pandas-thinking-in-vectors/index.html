<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Required meta tags always come first -->
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Pandas: Thinking in Vectors | David Asboth | Data Science
</title>
  <link rel="canonical" href="/blog/pandas-thinking-in-vectors/index.html">

  <link rel="alternate" type="application/atom+xml" href="/feeds/all.atom.xml" title="Full Atom Feed">
  <link rel="alternate" type="application/atom+xml" href="/feeds/category.slug.atom.xml" title="Categories Atom Feed">


  <link rel="stylesheet" href="/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="/theme/css/pygments/default.min.css">
  <link rel="stylesheet" href="/theme/css/style.css">


<meta name="description" content="The more you use pandas to wrangle your data the more likely you'll come across something complicated that you won't be sure how to do. I found this quite quickly when trying to calculate metrics with time series data for example. In these cases quite often the first solution that …">
</head>

<body>
  <header class="header">
    <div class="container">
      <div class="row">
        <div class="col-sm-12">
          <h1 class="title"><a href="/">David Asboth | Data Science</a></h1>
        </div>
      </div>
    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>Pandas: Thinking in Vectors
</h1>
      <hr>
<article class="article">
  <header>
    <ul class="list-inline">
<!--
      <li class="list-inline-item text-muted" title="2016-11-04T20:35:00+00:00">
        <i class="fa fa-clock-o"></i>
        Fri 04 November 2016
      </li>
-->
      <li class="list-inline-item">
        <i class="fa fa-folder-open-o"></i>
        <a href="/category/data-science.html">data science</a>
      </li>
      <li class="list-inline-item">
        <i class="fa fa-files-o"></i>
        <a href="/tag/pandas.html">#pandas</a>,         <a href="/tag/python.html">#python</a>      </li>
    </ul>
  </header>
  <div class="content">
    <p>The more you use pandas to wrangle your data the more likely you'll come
across something complicated that you won't be sure how to do. I found
this quite quickly when trying to calculate metrics with time series
data for example.</p>
<p>In these cases quite often the first solution that pops into my head
will be the naive, brute force one. Something like "well we can loop
through all the rows and perform a computation on each row one by one".</p>
<p>That is almost never the right approach, because it will be <em>slow</em>.</p>
<p>The better solution is almost always to make use of vectorisation.</p>
<p>Pandas is built on top of numpy, which is built with vectors in mind -
that is, manipulating entire arrays at once rather than the individual
elements.</p>
<p>That way of thinking can be a hard to adjust to when the temptation is
to use loops.</p>
<p>Sometimes it's not a bad idea to start with the brute force approach to
be confident of the answer, and then move to a vectorised solution. For
large datasets though, this move can easily be the difference between
the script taking seconds or hours to run.</p>
<h1>Examples</h1>
<h2>Date Methods</h2>
<p>Applying methods to a column of date values is a common data
manipulation task, for example when extracting the day as a new feature.
There are (at least) two functionally identical ways of doing this:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Method 1 - row by row</span>
<span class="n">days</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">my_dataframe</span><span class="p">[</span><span class="s2">&quot;my_date_column&quot;</span><span class="p">]:</span>
    <span class="n">days</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">day</span><span class="p">)</span>
<span class="n">my_dataframe</span><span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">days</span>

<span class="c1"># Method 2 - using the inbuilt and vectorised date functionality</span>
<span class="n">my_dataframe</span><span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_dataframe</span><span class="p">[</span><span class="s2">&quot;my_date_column&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day</span>
</code></pre></div>

<p>They'll do exactly the same thing, but the second will be orders of
magnitude faster.</p>
<h2>Subtracting Consecutive Values</h2>
<p>This is one of those problems where, if you don't know the pandas way to
do it, it's easy to start thinking row by row.</p>
<p>Again, here are two functionally identical ways of doing it:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Method 1 - a function to loop through the elements one by one</span>
<span class="k">def</span> <span class="nf">naive_diff</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
    <span class="n">diff_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)):</span>
        <span class="c1"># first value needs to be NaN</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">diff_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diff_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">diff_values</span>

<span class="n">df</span><span class="p">[</span><span class="s2">&quot;diff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">naive_diff</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;measurement&quot;</span><span class="p">])</span>

<span class="c1"># Method 2 - using the pandas shift() function</span>
<span class="n">df</span><span class="p">[</span><span class="s2">&quot;diff_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;measurement&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;measurement&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">()</span>
</code></pre></div>

<p>As well as being shorter, the second method is again much faster.</p>
<h1>Conclusion</h1>
<p>This was just a <em>very</em> brief introduction into thinking in vectors when
using pandas.</p>
<p>The code is available <a href="https://github.com/davidasboth/blog-notebooks/blob/master/pandas-thinking-in-vectors/pandas-vector-examples.ipynb">as a Jupyter notebook</a>.</p>
<p>The take away message is that whenever you need to do something to each
row, it's worth spending time doing some research to look for an
appropriate, in built function, and thinking a bit harder about how to
solve it in a vectorised way.</p>
<h2>Footnote: Apply and Itertuples</h2>
<p>If you absolutely must loop through the dataframe row by row, you should
consider using apply and itertuples. They are two pandas functions that
let you perform elementwise computation, but are faster than manually
looping through the row indices.</p>
<p>There are further good tips <a href="http://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas">under this StackOverflow question</a>.</p>
<h2>Further Reading</h2>
<p>When doing some research for this post I came across <a href="https://www.datascience.com/blog/straightening-loops-how-to-vectorize-data-aggregation-with-pandas-and-numpy/">this blog post</a>,
which is worth a read on the subject.</p>
<p>Footnote #2: This was the 4<sup>th</sup> entry in my <a href="/blog/30-posts-in-30-days/">30 day blog challenge</a>.</p><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</article>
    </div>
  </div>

  <footer class="footer">
    <div class="container">
      <div class="row">
       <div class="col-sm-6"></div>
       <p class="col-sm-6 text-sm-right text-muted">
          Generated by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a> / <a href="https://github.com/nairobilug/pelican-alchemy" target="_blank">&#x2728;</a>
       </p>
      </div>
    </div>
  </footer>
</body>

</html>